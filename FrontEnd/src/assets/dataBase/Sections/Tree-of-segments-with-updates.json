{
    "title": "Дерево отрезков с добавлением модификаторов (range update)",
    "content": ["        Стандартное дерево отрезков позволяет выполнять базовые операции, такие как запросы и обновления. Однако часто возникают ситуации, когда необходимо выполнить дополнительные модификации. Модификации дерева отрезков позволяют выполнять запросы изменения, которые затрагивают целые отрезки, без необходимости обновлять все элементы вручную. Основной задачей здесь становится сохранение эффективности: любые модификации должны выполняться за O(logN) на запрос.", "__Принципы работы дерева отрезков с модификациями:__\n        Для начала нам нужно понять 2 основных принципа работы с таким деревом:\n 1. Рекурсивное обновление: дерево отрезков устроено так, что каждый узел отвечает за некоторый отрезок массива. Обновление элемента затрагивает только те узлы, которые непосредственно связаны с этим элементом. В случае обновления целого отрезка необходимо обновить значения узлов дерева, которые соответствуют этому отрезку.\n\n 2. Запаздывающее обновление (Lazy Propagation*): запаздывающее обновление позволяет избежать немедленного обновления всех узлов дерева. Вместо этого хранится информация о том, что отрезок требует обновления. Реальное обновление выполняется только тогда, когда это необходимо (например, при запросе суммы или значений). Это помогает ускорить обработку запросов, касающихся больших отрезков.\n\n ***Lazy Propagation** — это способ оптимизации обработки модификаций дерева отрезков. Вместо того чтобы немедленно обновлять значения в дереве, используется специальный флаг, указывающий, что необходимо применить изменения позднее.\n\n        В каждом узле дерева хранится флаг, который указывает, что отрезок, покрываемый этим узлом, требует модификации. Когда необходимо получить значение на отрезке, флаг обновления применяется, и данные узла корректируются. После этого флаг сбрасывается. При необходимости изменения передаются на дочерние узлы, так что обновления происходят только тогда, когда это действительно необходимо.","__Рассмотрим несколько наиболее распространенных модификаций:__\n\n**1. Обновление отрезка прибавлением (+X)**\n        Этот тип запроса увеличивает все элементы массива на отрезке [L,R] на фиксированное значение X. При этом физическое изменение элементов не выполняется сразу. Вместо этого дерево отрезков модифицируется так, чтобы учесть изменения на отрезке при обработке следующих запросов.\n\n        Для выполнения обновления используется техника Lazy Propagation, при которой в узле дерева не сразу обновляется значение, а устанавливается флаг, который сигнализирует о необходимости внесения изменений. Обновление выполняется не мгновенно, а только когда требуется получить данные, затрагивающие этот отрезок.\n\n        Этот алгоритм эффективен для изменений на больших отрезках, поскольку позволяет избежать частых обновлений каждого элемента в отрезке.\n        Модификация отрезка выполняется за O(logN), так как затронуты только узлы на пути от листа к корню дерева.","**2. Присвоение значения всем элементам отрезка (==X)**\n        Этот запрос задает всем элементам массива на отрезке [L,R] конкретное значение X. Вместо непосредственного обновления значений каждого элемента на отрезке, в дереве отрезков фиксируются изменения с использованием флагов.\n\n        При выполнении запроса дерево отрезков обновляется не сразу, а сохраняет информацию о том, что все элементы на отрезке должны быть установлены в новое значение. Для корректного пересчёта всех подотрезков потребуется правильно обработать эти изменения, когда они будут запрашиваться.\n\n        Как и во всех модификациях, связанных с lazy Propagation, преимуществом является обновление всех элементов отрезка без необходимости изменять каждый элемент сразу, что ускоряет и упрощает работу алгоритма.\n\n        Модификация отрезка выполняется за O(logN), включая обработку флагов обновлений и последующие изменения значений.","**3. Запрос значений элемента**\n        Этот запрос позволяет получить значение элемента массива после ряда модификаций. Чтобы верно вычислить значение, дерево отрезков должно учесть все предыдущие изменения, затронувшие этот элемент.\n\n        При запросе значения элемента, дерево отрезков проверяет флаги обновлений на пути от узла до корня. Если на пути встречаются флаги, они применяются к значениям узлов, после чего возвращается актуальное значение элемента. Эта модификация обеспечивает получение корректного значения элемента после всех модификаций отрезка.\n\n        Запрос значения выполняется за O(logN), поскольку необходимо обработать все «ленивые» флаги по пути от узла до корня дерева.","**4. Комбинированные запросы**\n        Этот тип запросов требует выполнения нескольких операций на отрезке одновременно, например, «увеличить все элементы на отрезке [L,R] на X и найти минимальное значение на другом отрезке [L1, R1]».\n\n        Для комбинированных запросов сначала выполняется необходимая модификация на одном отрезке (например, прибавление X), а затем выполняется другой запрос (например, нахождение минимума на другом отрезке). При этом дерево отрезков учитывает все предыдущие модификации, обеспечивая актуальные результаты для различных типов запросов.\n\n        Этот подход позволяет эффективно комбинировать несколько запросов, что экономит время по сравнению с последовательным выполнением отдельных запросов.\n\n        Каждый запрос выполняется за O(logN), так как дерево отрезков эффективно обрабатывает модификации и агрегированные данные."],
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint len_mass, left_limit, right_limit; //длина массива, левая и правая границы отрезка\nint mass[1000];//массив\nint tree[100000]; //дерево отрезков. в вершинах хранятся суммы\n\n//Построение дерева по изначальному массиву\nvoid build_tree(int node, int left_element, int right_element) {//node - номер текущей вершины(узла); left_element, right_element - границы соответствующего отрезка\n    if (left_element == right_element) {\n        tree[node] = mass[left_element];//сумма отрезка из одного элемента равна этому элементу\n    } \n    else {\n        //отрезок разбивается на два отрезка [left_element; middle_element], [middle_element + 1; right_element]\n        int middle_element = (left_element + right_element) / 2; //middle_element - средний элемент отрезка\n        build_tree(node*2, left_element, middle_element);//помним, что детьми 1 будут 2 и 3, а детьми 3 будут 6 и 7; для любого индекса node справедливо, что его дети node*2 и node*2+1\n        build_tree(node*2+1, middle_element+1, right_element);\n        tree[node] = min(tree[node*2], tree[node*2+1]);    //сохраняем минимум вместо суммы\n    }\n}\n\n//Запрос суммы\nint get_min(int left_limit, int right_limit, int node, int left_element, int right_element) {//left_limit, right_limit - границы запроса,node - номер текущей вершины, left_element, right_element - границы соответствующего отрезка\n    if (left_limit <= left_element && right_element <= right_limit) {//текущий отрезок полностью входит в запрос\n        return tree[node];\n    }\n\n    if (right_element < left_limit || right_limit < left_element) {//Текущий отрезок полностью не входит в запрос\n        return INT_MAX;//Значение, которое не повлияет на общий минимум\n    }\n    \n    int middle_element = (left_element + right_element) / 2; //Текущий отрезок частично входит в запрос\n    return min(get_min(left_limit, right_limit, node*2, left_element, middle_element), get_min(left_limit, right_limit, node*2+1, middle_element+1, right_element));     //минимум вместо суммы.\n}\n\n//Запрос модификации\nvoid update(int index, int value, int node, int left_element, int right_element) { //index - индекс элемента, value - новое значение, node - номер текущей вершины, left_element, right_element - границы соответствующего отрезка\n    if (index <= left_element && right_element <= index) {//Если отрезок длины 1\n        mass[index]=value;\n        tree[node]=value;\n        return;\n    }\n\n    if (right_element < index || index < left_element) {//не выходит в отрезок\n        return;\n    }\n\n    int middle_element = (left_element + right_element) / 2; //делим отрезок на 2 подотрезка\n    update(index, value, node*2, left_element, middle_element);\n    update(index, value, node*2+1, middle_element + 1, right_element);\n    tree[node]=min(tree[node*2], tree[node*2+1]); //минимум вместо суммы\n}\n\nint main() {\n    cin >> len_mass;\n    for (int i =0; i<len_mass; i++){\n        cin >> mass[i];\n    }\n    cin >> left_limit >> right_limit;\n\n    build_tree(1, 0, len_mass-1);    //параметры корня дерева.\n                                //все запросы должны вызываться для этих параметров.\n                                \n    cout << get_min(left_limit, right_limit, 1, 0, len_mass-1);\n\n    //Можно делать запросы вида get_min(left_limit, right_limit, 1, 0, len_mass-1) и update(index, value, 1, 0, len_mass-1);\n}",
    "visualization": "Здесь будет визуализация, если повезет"
  }