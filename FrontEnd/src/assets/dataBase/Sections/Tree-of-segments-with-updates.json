{
    "title": "Дерево отрезков с добавлением модификаторов (range update)",
    "content": ["        Стандартное дерево отрезков позволяет выполнять базовые операции, такие как запросы и обновления. Однако часто возникают ситуации, когда необходимо выполнить дополнительные модификации. Модификации дерева отрезков позволяют выполнять запросы изменения, которые затрагивают целые отрезки, без необходимости обновлять все элементы вручную. Основной задачей здесь становится сохранение эффективности: любые модификации должны выполняться за O(logN) на запрос.", "__Принципы работы дерева отрезков с модификациями:__\n        Для начала нам нужно понять 2 основных принципа работы с таким деревом:\n 1. Рекурсивное обновление: дерево отрезков устроено так, что каждый узел отвечает за некоторый отрезок массива. Обновление элемента затрагивает только те узлы, которые непосредственно связаны с этим элементом. В случае обновления целого отрезка необходимо обновить значения узлов дерева, которые соответствуют этому отрезку.\n\n 2. Запаздывающее обновление (Lazy Propagation*): запаздывающее обновление позволяет избежать немедленного обновления всех узлов дерева. Вместо этого хранится информация о том, что отрезок требует обновления. Реальное обновление выполняется только тогда, когда это необходимо (например, при запросе суммы или значений). Это помогает ускорить обработку запросов, касающихся больших отрезков.\n\n ***Lazy Propagation** — это способ оптимизации обработки модификаций дерева отрезков. Вместо того чтобы немедленно обновлять значения в дереве, используется специальный флаг, указывающий, что необходимо применить изменения позднее.\n\n        В каждом узле дерева хранится флаг, который указывает, что отрезок, покрываемый этим узлом, требует модификации. Когда необходимо получить значение на отрезке, флаг обновления применяется, и данные узла корректируются. После этого флаг сбрасывается. При необходимости изменения передаются на дочерние узлы, так что обновления происходят только тогда, когда это действительно необходимо.","__Рассмотрим несколько наиболее распространенных модификаций:__\n\n**1. Обновление отрезка прибавлением (+X)**\n        Этот тип запроса увеличивает все элементы массива на отрезке [L,R] на фиксированное значение X. При этом физическое изменение элементов не выполняется сразу. Вместо этого дерево отрезков модифицируется так, чтобы учесть изменения на отрезке при обработке следующих запросов.\n\n        Для выполнения обновления используется техника Lazy Propagation, при которой в узле дерева не сразу обновляется значение, а устанавливается флаг, который сигнализирует о необходимости внесения изменений. Обновление выполняется не мгновенно, а только когда требуется получить данные, затрагивающие этот отрезок.\n\n        Этот алгоритм эффективен для изменений на больших отрезках, поскольку позволяет избежать частых обновлений каждого элемента в отрезке.\n        Модификация отрезка выполняется за O(logN), так как затронуты только узлы на пути от листа к корню дерева.","**2. Присвоение значения всем элементам отрезка (==X)**\n        Этот запрос задает всем элементам массива на отрезке [L,R] конкретное значение X. Вместо непосредственного обновления значений каждого элемента на отрезке, в дереве отрезков фиксируются изменения с использованием флагов.\n\n        При выполнении запроса дерево отрезков обновляется не сразу, а сохраняет информацию о том, что все элементы на отрезке должны быть установлены в новое значение. Для корректного пересчёта всех подотрезков потребуется правильно обработать эти изменения, когда они будут запрашиваться.\n\n        Как и во всех модификациях, связанных с lazy Propagation, преимуществом является обновление всех элементов отрезка без необходимости изменять каждый элемент сразу, что ускоряет и упрощает работу алгоритма.\n\n        Модификация отрезка выполняется за O(logN), включая обработку флагов обновлений и последующие изменения значений.","**3. Запрос значений элемента**\n        Этот запрос позволяет получить значение элемента массива после ряда модификаций. Чтобы верно вычислить значение, дерево отрезков должно учесть все предыдущие изменения, затронувшие этот элемент.\n\n        При запросе значения элемента, дерево отрезков проверяет флаги обновлений на пути от узла до корня. Если на пути встречаются флаги, они применяются к значениям узлов, после чего возвращается актуальное значение элемента. Эта модификация обеспечивает получение корректного значения элемента после всех модификаций отрезка.\n\n        Запрос значения выполняется за O(logN), поскольку необходимо обработать все «ленивые» флаги по пути от узла до корня дерева.","**4. Комбинированные запросы**\n        Этот тип запросов требует выполнения нескольких операций на отрезке одновременно, например, «увеличить все элементы на отрезке [L,R] на X и найти минимальное значение на другом отрезке [L1, R1]».\n\n        Для комбинированных запросов сначала выполняется необходимая модификация на одном отрезке (например, прибавление X), а затем выполняется другой запрос (например, нахождение минимума на другом отрезке). При этом дерево отрезков учитывает все предыдущие модификации, обеспечивая актуальные результаты для различных типов запросов.\n\n        Этот подход позволяет эффективно комбинировать несколько запросов, что экономит время по сравнению с последовательным выполнением отдельных запросов.\n\n        Каждый запрос выполняется за O(logN), так как дерево отрезков эффективно обрабатывает модификации и агрегированные данные."],
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000;       // Maximum array size\nconst int MAX_TREE = 4000;    // Tree size (4*MAX_N for safety)\n\n// Update single element at position 'pos' (adds X)\nvoid update_element(int tree[], int node, int node_left, int node_right, int pos, int X) {\n    // Leaf node case\n    if (node_left == node_right) {\n        tree[node] += X;\n        return;\n    }\n    int mid = (node_left + node_right) / 2;\n    // Update left or right subtree\n    if (pos <= mid) {\n        update_element(tree, 2*node, node_left, mid, pos, X);\n    } else {\n        update_element(tree, 2*node+1, mid+1, node_right, pos, X);\n    }\n    // Update current node value\n    tree[node] = tree[2*node] + tree[2*node+1];\n}\n\n// Get sum of elements in range [L, R]\nint get_sum(int tree[], int node, int node_left, int node_right, int L, int R) {\n    // Current segment completely within query range\n    if (L <= node_left && node_right <= R) {\n        return tree[node];\n    }\n    // Current segment completely outside query range\n    if (node_right < L || R < node_left) {\n        return 0;\n    }\n    int mid = (node_left + node_right) / 2;\n    return get_sum(tree, 2*node, node_left, mid, L, R) + \n           get_sum(tree, 2*node+1, mid+1, node_right, L, R);\n}\n\n// Get value at specific position X\nvoid get_element(int tree[], int X, int N) {\n    cout << 'Element at index' << X << ': ' \n         << get_sum(tree, 1, 0, N-1, 0, X) << endl;\n}\n\n// Update range [L, R] by adding X (using prefix sums)\nvoid update_range(int tree[], int L, int R, int X, int N) {\n    // Add X at L position\n    update_element(tree, 1, 0, N-1, L, X);\n    // Subtract X at R+1 position (prefix sum technique)\n    if (R+1 < N) {\n        update_element(tree, 1, 0, N-1, R+1, -X);\n    }\n}\n\nint main() {\n    const int N = 5;  // Array size\n    int tree[MAX_TREE] = {0};  // Initialize segment tree\n    // Sample queries: \n    // {1, L, R, X} - add X to range [L, R]\n    // {2, X} - get value at index X\n    vector<vector<int>> queries = {\n        {1, 0, 1, 100},  // Add 100 to elements 0 and 1\n        {2, 1}           // Get value at index 1\n    };\n    // Process queries\n    for (auto& query : queries) {\n        if (query[0] == 1) {\n            update_range(tree, query[1], query[2], query[3], N);\n        } else {\n            get_element(tree, query[1], N);\n        }\n    }\n    return 0;\n}",
    "visualization": "Здесь будет визуализация, если повезет"
  }