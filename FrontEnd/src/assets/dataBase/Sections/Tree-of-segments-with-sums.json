{
  "title": "Дерево отрезков с суммами",
  "content": ["        Дерево отрезков с суммами — это структура данных, преднзначенная для эффективных вычислений сумм на подотрезках массива. Она позволяет быстро (за логарифмическое время) вычислять сумму элементов на отрезке и обновлять элементы массива.\n\n         Дерево отрезков - структура данных, позволяющая выполнять многие операции с отрезками массива за O(logN). Дерево отрезков - универсальная структура данных, для которой можно реализовать неограниченный набор операций (иногда за большую сложность: O(log2N)).","__Для чего нужен этот алгоритм?__\n        К примеру, представьте, что надо найти сумму последовательности чисел, при этом нам нужно не просто вычислить сумму чисел указанной последовательности (сумму элементов определённого массива), а максимально быстро найти сумму любой последовательности из этих чисел. То есть мы можем задать какой-нибудь интервал (отрезок) и максимально быстро дать ответ, чему равна сумма чисел из этого интервала.\n\n        Что значит быстро? Это значит быстрее, чем, если бы мы просто суммировали числа. Ведь чисел может быть и миллионы, и миллиарды…\n        Именно желание быстро находить сумму последовательных элементов и стало мотивацией для создания данного алгоритма. Причём, речь идёт не только о сумме, но и о других задачах, например, вычислении любой ассоциативной функции. Таким образом, мы говорим об операциях, выполнение которых не зависит от порядка вычисления.","__Построение дерева отрезков__\n        Дерево отрезков - полное бинарное дерево, в котором каждая вершина отвечает за некоторый отрезок в массиве. Корень дерева отвечает за весь массив, его две дочерних вершины - за две половины, и так далее. У каждой вершины, отвечающей за отрезок длиной больше 1, есть две дочерних вершины, отвечающих за левую и правую половины этого отрезка. Листья дерева отрезков отвечают за отдельные элементы (отрезки длиной 1).\n\n        Для массива из n элементов дерево отрезков имеет около 2n вершин (n+n/2+n/4+…), а его высота равна порядка logn.\n\n        Главное свойство дерева отрезков, на котором и строятся все алгоритмы работы с ним: любой непрерывный отрезок в массиве из n элементов можно представить с помощью около 2logn вершин в дереве отрезков.","**Несколько важных замечаний!!!**\n    • Нумеровать этот массив удобно с единицы. Таким образом легко вычислять номер детей и родителей. Формула вычисления «левого ребёнка»: i*2, «правого»: i*2+1.\n    • Чтобы от \"ребенка\" подняться к \"родителю\", используем целочисленное деление i / 2.\n    • У левых детей чётные номера, у правых — нечётные.","__Описание алгоритма__\n        Мы знаем, что во всех вершинах лежат корректные значения. Тогда мы можем создать рекурсивную функцию, рассмотрев три случая:\n    • Если отрезок вершины лежит целиком в отрезке запроса, то вернуть записанную в ней сумму.\n    • Если отрезки вершины и запроса не пересекаются, то вернуть 0.\n    • Иначе разделиться рекурсивно на 2 и вернуть сумму этой функции от обоих детей.\n\n        Чтобы разобраться, почему это работает за O(logn), нужно оценить количество «интересных» отрезков — тех, которые порождают новые вызовы рекурсии. Это будут только те, которые содержат границу запросов — остальные сразу завершатся. Обе границы отрезка содержатся в O(logn) отрезках, а значит и итоговая асимптотика будет такая же."],
  "code" : "#include <bits/stdc++.h>\nusing namespace std;\n\nint len_mass, left_limit, right_limit; //длина массива, левая и правая границы отрезка\nint mass[1000];//массив\nint tree[100000]; //дерево отрезков. в вершинах хранятся суммы\n\n//Построение дерева по изначальному массиву\nvoid build_tree(int node, int left_element, int right_element) {//node - номер текущей вершины(узла);\nleft_element, right_element - границы соответствующего отрезка\n    if (left_element == right_element) {\n        tree[node] = mass[left_element];//сумма отрезка из одного элемента равна этому элементу\n    }\n    else {\n        //отрезок разбивается на два отрезка [left_element; middle_element], [middle_element + 1; right_element]\n        int middle_element = (left_element + right_element) / 2; //middle_element - средний элемент отрезка\n        build_tree(node*2, left_element, middle_element);//помним, что детьми 1 будут 2 и 3, а детьми 3 будут 6 и 7; для любого индекса node справедливо, что его дети node*2 и node*2+1\n        build_tree(node*2+1, middle_element+1, right_element);\n        tree[node] = tree[node*2] + tree[node*2+1]; //сумма отрезка это сумма двух подотрезков\n    }\n}\n\n//Запрос суммы\nint get_sum(int left_limit, int right_limit, int node, int left_element, int right_element) {//left_limit, right_limit - границы запроса,node - номер текущей вершины, left_element, right_element - границы соответствующего отрезка\n    if (left_limit <= left_element && right_element <= right_limit) {//текущий отрезок полностью входит в запрос\n        return tree[node];\n    }\n\n    if (right_element < left_limit || right_limit < left_element) {//Текущий отрезок полностью не входит в запрос\n        return 0;\n    }\n\n    int middle_element = (left_element + right_element) / 2; //Текущий отрезок частично входит в запрос\n    return get_sum(left_limit, right_limit, node*2, left_element, middle_element) + get_sum(left_limit, right_limit, node*2+1, middle_element+1, right_element); //ищем сумму для подотрезков, расширяя границы\n}\n\n//Запрос модификации\nvoid update(int index, int value, int node, int left_element, int right_element) { //index - индекс элемента, value - новое значение, node - номер текущей вершины, left_element, right_element - границы соответствующего отрезка\n    if (index <= left_element && right_element <= index) {//Если отрезок длины 1\n        mass[index]=value;\n        tree[node]=value;\n        return;\n    }\n\n    if (right_element < index || index < left_element) {//не выходит в отрезок\n        return;\n    }\n\n    int middle_element = (left_element + right_element) / 2; //делим отрезок на 2 подотрезка\n    update(index, value, node*2, left_element, middle_element);\n    update(index, value, node*2+1, middle_element + 1, right_element);\n    tree[node] = tree[node*2] + tree[node*2+1];//обновляем сумму для данного элемента\n}\n\nint main() {\n    cin >> len_mass;\n    for (int i =0; i<len_mass; i++){\n        cin >> mass[i];\n    }\n    cin >> left_limit >> right_limit;\n\n    build_tree(1, 0, len_mass-1);    //параметры корня дерева.\n                                //все запросы должны вызываться для этих параметров.\n\n    cout << get_sum(left_limit, right_limit, 1, 0, len_mass-1);\n\n    //Можно делать запросы вида get_sum(l, r, 1, 0, n - 1) и update(idx, val, 1, 0, n - 1);\n}",
  "visualization": "Здесь будет визуализация дерева отрезков."
}
