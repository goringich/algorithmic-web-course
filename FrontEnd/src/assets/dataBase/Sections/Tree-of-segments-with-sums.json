{
  "title": "Дерево отрезков с суммами",
  "content": ["        Дерево отрезков с суммами — это структура данных, преднзначенная для эффективных вычислений сумм на подотрезках массива. Она позволяет быстро (за логарифмическое время) вычислять сумму элементов на отрезке и обновлять элементы массива.\n\n         Дерево отрезков - структура данных, позволяющая выполнять многие операции с отрезками массива за O(logN). Дерево отрезков - универсальная структура данных, для которой можно реализовать неограниченный набор операций (иногда за большую сложность: O(log2N)).","__Для чего нужен этот алгоритм?__\n        К примеру, представьте, что надо найти сумму последовательности чисел, при этом нам нужно не просто вычислить сумму чисел указанной последовательности (сумму элементов определённого массива), а максимально быстро найти сумму любой последовательности из этих чисел. То есть мы можем задать какой-нибудь интервал (отрезок) и максимально быстро дать ответ, чему равна сумма чисел из этого интервала.\n\n        Что значит быстро? Это значит быстрее, чем, если бы мы просто суммировали числа. Ведь чисел может быть и миллионы, и миллиарды…\n        Именно желание быстро находить сумму последовательных элементов и стало мотивацией для создания данного алгоритма. Причём, речь идёт не только о сумме, но и о других задачах, например, вычислении любой ассоциативной функции. Таким образом, мы говорим об операциях, выполнение которых не зависит от порядка вычисления.","__Построение дерева отрезков__\n        Дерево отрезков - полное бинарное дерево, в котором каждая вершина отвечает за некоторый отрезок в массиве. Корень дерева отвечает за весь массив, его две дочерних вершины - за две половины, и так далее. У каждой вершины, отвечающей за отрезок длиной больше 1, есть две дочерних вершины, отвечающих за левую и правую половины этого отрезка. Листья дерева отрезков отвечают за отдельные элементы (отрезки длиной 1).\n\n        Для массива из n элементов дерево отрезков имеет около 2n вершин (n+n/2+n/4+…), а его высота равна порядка logn.\n\n        Главное свойство дерева отрезков, на котором и строятся все алгоритмы работы с ним: любой непрерывный отрезок в массиве из n элементов можно представить с помощью около 2logn вершин в дереве отрезков.","**Несколько важных замечаний!!!**\n    • Нумеровать этот массив удобно с единицы. Таким образом легко вычислять номер детей и родителей. Формула вычисления «левого ребёнка»: i*2, «правого»: i*2+1.\n    • Чтобы от \"ребенка\" подняться к \"родителю\", используем целочисленное деление i / 2.\n    • У левых детей чётные номера, у правых — нечётные.","__Описание алгоритма__\n        Мы знаем, что во всех вершинах лежат корректные значения. Тогда мы можем создать рекурсивную функцию, рассмотрев три случая:\n    • Если отрезок вершины лежит целиком в отрезке запроса, то вернуть записанную в ней сумму.\n    • Если отрезки вершины и запроса не пересекаются, то вернуть 0.\n    • Иначе разделиться рекурсивно на 2 и вернуть сумму этой функции от обоих детей.\n\n        Чтобы разобраться, почему это работает за O(logn), нужно оценить количество «интересных» отрезков — тех, которые порождают новые вызовы рекурсии. Это будут только те, которые содержат границу запросов — остальные сразу завершатся. Обе границы отрезка содержатся в O(logn) отрезках, а значит и итоговая асимптотика будет такая же."],
  "code": "class SegmentTree {...}",
  "visualization": "Здесь будет визуализация дерева отрезков."
}
