{
    "title": "Дерево отрезков с минимальными/максимальными значениями",
    "content": ["        Дерево отрезков для минимума и максимума строится по тому же принципу, что и классическое дерево отрезков для сумм, но с ключевыми отличиями в операциях. Вместо хранения и вычисления сумм на отрезках, эта структура данных хранит минимальные и максимальные значения, что позволяет эффективно решать задачи поиска экстремумов на любом интервале исходного массива.\n        Главными отличиями в функциях являются замена суммы на минимум (максимум) и изменение нейтрального элемента на +∞ (-∞).","        Процесс построения аналогичен дереву для сумм, но вместо суммирования значений детей используется выбор минимума(максимума). Дерево отрезков для минимума/максимума сохраняет все преимущества классической структуры - логарифмическое время запросов и обновлений, при этом решая более специализированные задачи поиска экстремальных значений. Эта модификация находит широкое применение в анализе данных и алгоритмических задачах, где требуется быстрый доступ к минимальным и максимальным значениям на произвольных интервалах."],
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000;       // Maximum array size\nconst int MAX_TREE = 4000;    // Tree size (4*MAX_N for safety)\nint len_mass, left_limit, right_limit;\nint mass[MAX_N];              // Input array\nint tree[MAX_TREE];           // Segment tree storing minimum values\n\n// Build segment tree for range minimum queries\nvoid build_tree(int node, int left_element, int right_element) {\n    // Leaf node case\n    if (left_element == right_element) {\n        tree[node] = mass[left_element];\n        return;\n    }\n    // Recursively build left and right subtrees\n    int mid = (left_element + right_element) / 2;\n    build_tree(node*2, left_element, mid);\n    build_tree(node*2+1, mid+1, right_element);\n    // Store minimum of two children\n    tree[node] = min(tree[node*2], tree[node*2+1]);//tree[node] = max(tree[node*2], tree[node*2+1]);\n}\n\n// Query minimum in range [L, R]\nint get_min(int L, int R, int node, int node_L, int node_R) {//get_max\n    // Current segment completely within query range\n    if (L <= node_L && node_R <= R) \n        return tree[node];\n    // Current segment completely outside query range\n    if (node_R < L || R < node_L)\n        return INT_MAX;  // Neutral value for min operation \n                         // or return INT_MIN;\n    // Partial overlap - query both children\n    int mid = (node_L + node_R) / 2;\n    return min(//max\n        get_min(L, R, node*2, node_L, mid),//get_max\n        get_min(L, R, node*2+1, mid+1, node_R)//get_max\n    );\n}\n\n// Update value at position 'index'\nvoid update(int index, int value, int node, int node_L, int node_R) {\n    // Found the leaf node to update\n    if (node_L == node_R) {\n        mass[index] = value;\n        tree[node] = value;\n        return;\n    }\n    // Ignore if index outside current segment\n    if (index < node_L || node_R < index)\n        return;\n    // Recursively update the appropriate child\n    int mid = (node_L + node_R) / 2;\n    update(index, value, node*2, node_L, mid);\n    update(index, value, node*2+1, mid+1, node_R);\n    // Update current node with new minimum\n    tree[node] = min(tree[node*2], tree[node*2+1]);//tree[node] = max(tree[node*2], tree[node*2+1]);\n}\n\nint main() {\n    // Input array\n    cin >> len_mass;\n    for (int i = 0; i < len_mass; i++)\n        cin >> mass[i];\n    // Input query range\n    cin >> left_limit >> right_limit;\n    // Build segment tree\n    build_tree(1, 0, len_mass-1);\n    // Execute range minimum query\n    cout << 'Minimum in range [' << left_limit << ', ' << right_limit << ']: ';//Maximum in range\n    cout << get_min(left_limit, right_limit, 1, 0, len_mass-1) << endl;//get_max\n    return 0;\n}",
    "visualization": ""
  }