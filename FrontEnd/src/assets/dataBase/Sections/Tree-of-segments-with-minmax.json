{
    "title": "Дерево отрезков с минимальными/максимальными значениями",
    "content": "",
    "code": "//Код для нахождения минимума\n#include <bits/stdc++.h>\nusing namespace std;\n\nint len_mass, left_limit, right_limit; //длина массива, левая и правая границы отрезка\nint mass[1000];//массив\nint tree[100000]; //дерево отрезков. в вершинах хранятся суммы\n\n//Построение дерева по изначальному массиву\nvoid build_tree(int node, int left_element, int right_element) {//node - номер текущей вершины(узла); left_element, right_element - границы соответствующего отрезка\n    if (left_element == right_element) {\n        tree[node] = mass[left_element];//сумма отрезка из одного элемента равна этому элементу\n    } \n    else {\n        //отрезок разбивается на два отрезка [left_element; middle_element], [middle_element + 1; right_element]\n        int middle_element = (left_element + right_element) / 2; //middle_element - средний элемент отрезка\n        build_tree(node*2, left_element, middle_element);//помним, что детьми 1 будут 2 и 3, а детьми 3 будут 6 и 7; для любого индекса node справедливо, что его дети node*2 и node*2+1\n        build_tree(node*2+1, middle_element+1, right_element);\n        tree[node] = min(tree[node*2], tree[node*2+1]);    //сохраняем минимум вместо суммы\n    }\n}\n\n//Запрос суммы\nint get_min(int left_limit, int right_limit, int node, int left_element, int right_element) {//left_limit, right_limit - границы запроса,node - номер текущей вершины, left_element, right_element - границы соответствующего отрезка\n    if (left_limit <= left_element && right_element <= right_limit) {//текущий отрезок полностью входит в запрос\n        return tree[node];\n    }\n\n    if (right_element < left_limit || right_limit < left_element) {//Текущий отрезок полностью не входит в запрос\n        return INT_MAX;//Значение, которое не повлияет на общий минимум\n    }\n    \n    int middle_element = (left_element + right_element) / 2; //Текущий отрезок частично входит в запрос\n    return min(get_min(left_limit, right_limit, node*2, left_element, middle_element), get_min(left_limit, right_limit, node*2+1, middle_element+1, right_element));     //минимум вместо суммы.\n}\n\n//Запрос модификации\nvoid update(int index, int value, int node, int left_element, int right_element) { //index - индекс элемента, value - новое значение, node - номер текущей вершины, left_element, right_element - границы соответствующего отрезка\n    if (index <= left_element && right_element <= index) {//Если отрезок длины 1\n        mass[index]=value;\n        tree[node]=value;\n        return;\n    }\n\n    if (right_element < index || index < left_element) {//не выходит в отрезок\n        return;\n    }\n\n    int middle_element = (left_element + right_element) / 2; //делим отрезок на 2 подотрезка\n    update(index, value, node*2, left_element, middle_element);\n    update(index, value, node*2+1, middle_element + 1, right_element);\n    tree[node]=min(tree[node*2], tree[node*2+1]); //минимум вместо суммы\n}\n\nint main() {\n    cin >> len_mass;\n    for (int i =0; i<len_mass; i++){\n        cin >> mass[i];\n    }\n    cin >> left_limit >> right_limit;\n\n    build_tree(1, 0, len_mass-1);    //параметры корня дерева.\n                                //все запросы должны вызываться для этих параметров.\n                                \n    cout << get_min(left_limit, right_limit, 1, 0, len_mass-1);\n\n    //Можно делать запросы вида get_min(left_limit, right_limit, 1, 0, len_mass-1) и update(index, value, 1, 0, len_mass-1);\n}\n\n\n-------------------------------------------------------------------------------------------------------------------\n//Аналогичный код для нахождения максимума\n#include <bits/stdc++.h>\nusing namespace std;\n\nint len_mass, left_limit, right_limit; //длина массива, левая и правая границы отрезка\nint mass[1000];//массив\nint tree[100000]; //дерево отрезков. в вершинах хранятся суммы\n\n//Построение дерева по изначальному массиву\nvoid build_tree(int node, int left_element, int right_element) {//node - номер текущей вершины(узла); left_element, right_element - границы соответствующего отрезка\n    if (left_element == right_element) {\n        tree[node] = mass[left_element];//максимум отрезка из одного элемента равен этому элементу\n    } \n    else {\n        //отрезок разбивается на два отрезка [left_element; middle_element], [middle_element + 1; right_element]\n        int middle_element = (left_element + right_element) / 2; //middle_element - средний элемент отрезка\n        build_tree(node*2, left_element, middle_element);//помним, что детьми 1 будут 2 и 3, а детьми 3 будут 6 и 7; для любого индекса node справедливо, что его дети node*2 и node*2+1\n        build_tree(node*2+1, middle_element+1, right_element);\n        tree[node] = max(tree[node*2], tree[node*2+1]);    //сохраняем максимум вместо суммы\n    }\n}\n\n//Запрос суммы\nint get_max(int left_limit, int right_limit, int node, int left_element, int right_element) {//left_limit, right_limit - границы запроса,node - номер текущей вершины, left_element, right_element - границы соответствующего отрезка\n    if (left_limit <= left_element && right_element <= right_limit) {//текущий отрезок полностью входит в запрос\n        return tree[node];\n    }\n\n    if (right_element < left_limit || right_limit < left_element) {//Текущий отрезок полностью не входит в запрос\n        return INT_MIN;//Значение, которое не повлияет на общий максимум\n    }\n    \n    int middle_element = (left_element + right_element) / 2; //Текущий отрезок частично входит в запрос\n    return max(get_max(left_limit, right_limit, node*2, left_element, middle_element), get_max(left_limit, right_limit, node*2+1, middle_element+1, right_element));     //максимум вместо суммы.\n}\n\n//Запрос модификации\nvoid update(int index, int value, int node, int left_element, int right_element) { //index - индекс элемента, value - новое значение, node - номер текущей вершины, left_element, right_element - границы соответствующего отрезка\n    if (index <= left_element && right_element <= index) {//Если отрезок длины 1\n        mass[index]=value;\n        tree[node]=value;\n        return;\n    }\n\n    if (right_element < index || index < left_element) {//не выходит в отрезок\n        return;\n    }\n\n    int middle_element = (left_element + right_element) / 2; //делим отрезок на 2 подотрезка\n    update(index, value, node*2, left_element, middle_element);\n    update(index, value, node*2+1, middle_element + 1, right_element);\n    tree[node]=max(tree[node*2], tree[node*2+1]); //максимум вместо суммы\n}\n\nint main() {\n    cin >> len_mass;\n    for (int i =0; i<len_mass; i++){\n        cin >> mass[i];\n    }\n    cin >> left_limit >> right_limit;\n\n    build_tree(1, 0, len_mass-1);    //параметры корня дерева.\n                                //все запросы должны вызываться для этих параметров.\n                                \n    cout << get_max(left_limit, right_limit, 1, 0, len_mass-1);\n\n    //Можно делать запросы вида get_max(left_limit, right_limit, 1, 0, len_mass-1) и update(index, value, 1, 0, len_mass-1);\n}",
    "visualization": "Здесь будет визуализация, если повезет"
  }