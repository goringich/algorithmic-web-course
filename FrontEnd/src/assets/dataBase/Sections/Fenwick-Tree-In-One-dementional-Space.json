{
    "title": "Дерево Фенвика в одномерном пространстве",
    "content": ["        Дерево Фенвика или двоичное индексированное дерево — это структура данных, используемая для вычисления запросов по диапазону, а также для обновления элементов массива таким образом, чтобы каждый запрос или обновление занимали логарифмическое время, а сама структура занимала в памяти O(n). Оно используется для вычисления префиксных сумм или текущего итога значений для любого индекса, заменяя при этом дерево отрезков и работая в 3-4 раза быстрее.",
     "__Определение__\n        Пусть дан массив a длины n. Деревом Фенвика будем называть массив t той же длины, объявленный следующим образом:\n$$T_i = \\sum_{k=F(i)^{i}} a_k$\nгде F это какая-то функцию, для которой выполнено F(i) <= i.\n\n        Функцию F можно выбрать так, чтобы спусков по дереву при подсчете суммы и ячеек, требующих изменений при обновлении, будет О(log n). Популярны две функции:\nF₁(x) = x & (x + 1)\nF₂(x) = x - (x & -x) + 1\n\n        Первая функция более известная, однако вторая легче для запоминания и кодинга в целом.",
     "__Основная идея__\n        Рассмотрим дерево Фенвика как массив F[ ] с индексацией, начинающейся с 1, в котором каждый индекс массива хранит частичную сумму диапазона. Для простоты предположим, что размер массива F[ ] равен 16. Таким образом, для любого индекса i, F[i] будет хранить сумму значений от индекса j+1 до i, где j = i - (самый правый установленный бит в i). Чтобы понять диапазон значений, обратитесь к [[TABLE_LINK]]:",
     {
      "type": "table",
      "headers": ["Значение i", "Двоичное представление", "Самый правый установленный бит i", "Значение j", "Диапазон частичной суммы [начало, конец]"],
      "rows": [
        ["0", "0000", "0000", "0000", " — "],
        ["1", "0001", "0001", "0000", "[1, 1]"],
        ["2", "0010", "0010", "0000", "[1, 2]"],
        ["3",  "0011", "0001", "0010", "[3, 3]"],
        ["4",  "0100", "0100", "0000", "[1, 4]"],
        ["5",  "0101", "0001", "0100", "[5, 5]"],
        ["6",  "0110", "0010", "0100", "[5, 6]"],
        ["7",  "0111", "0001", "0110", "[7, 7]"],
        ["8",  "1000", "1000", "0000", "[1, 8]"],
        ["9",  "1001", "0001", "1000", "[9, 9]"],
        ["10", "1010", "0010", "1000", "[9, 10]"],
        ["11", "1011", "0001", "1010", "[11, 11]"],
        ["12", "1100", "0100", "1000", "[9, 12]"],
        ["13", "1101", "0001", "1100", "[13, 13]"],
        ["14", "1110", "0010", "1100", "[13, 14]"],
        ["15", "1111", "0001", "1110", "[15, 15]"]
      ]
    },
    "        Итак, из приведённой выше таблицы мы видим, что каждый индекс дерева Фенвика F[ ] хранит сумму диапазона. Теперь, если нам нужно вычислить префиксную сумму до 7-го элемента, то вместо того, чтобы перебирать числа от 1 до 7 и вычислять сумму, мы можем взять сумму F[7] + F[6] + F[4].\n\n        Префиксная сумма до 7-го элемента = F[7] + F[6] + F[4], 7 --удалить самый правый установленный бит --> 6 --удалить самый правый установленный бит --> 4 --удалить самый правый установленный бит --> 0.\n\n        Теперь, чтобы вычислить сумму диапазона [L, R], мы можем просто вычесть сумму префиксов до [L-1] из суммы префиксов до R.",
  "__Запрос суммы__\n        ^^Когда нам нужна сумма на отрезке, мы будем сводить этот запрос к двум суммам на префиксе: sum(l,r) = sum(r) − sum(l−1). Оба этих запроса будем считать по формуле: sum(k) =tₖ + sum(F(k)−1)^^\n\n__Запрос обновления__\n        Когда мы изменяем k-ю ячейку исходного массива, мы обновляем все tᵢ, в которых учтена эта ячейка.",
"__Почему это работает?__\n        ^^Итак, мы выбрали вариант с F(x) = x-(x & -x)+1. Поймем, что означает x &-x.^^\n\n__Лемма__  ^^x & -x возвращает последний единичный бит в двоичной записи x.^^\n__Следствие 1__  ^^sum будет работать за логарифм, а точнее за количество единичных битов в записи x: на каждой итерации мы делаем x -= x & -x, то есть удаляем младший бит.^^\n__Следствие 2.__  ^^add тоже будет работать за логарифм: каждую итерацию количество нулей на конце x увеличивается хотя бы на единицу.^^\n__Следствие 3__  ^^(Почему дерево Фенвика — дерево.)^^\n\n1)  Длина отрезка, соответствующего любому tᵢ — степень двойки, причём начинается этот отрезок на индексе, кратном этой же степени двойки.\n2)  Множества элементов, учтённых в произвольных tᵢ и tⱼ, либо не пересекаются, либо одно является подмножеством другого.\n3)  На tᵢ можно ввести отношение вложенности.\n\n        То есть, если напрячь воображение, то t можно рассматривать как лес деревьев. В частном случае, когда n является степенью двойки, дерево будет одно. Теперь единственное, что осталось доказать — это корректность add. На самом деле, в add мы делаем ни что иное, как подъём от вершины до корня по всем предкам.\n        Как для x найти непосредственного родителя? Нужно найти минимальное число y>x, у которого ty будет включать x. Иными словами, должно выполняться y >= x > y - (y & -y)."],
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 100010;  // Maximum possible array size\nvector<int> F(MAX_N, 0);  // Fenwick tree (1-based indexing)\n// Add value X to element at position idx\nvoid add(int idx, int X) {\n    while (idx < MAX_N) {\n        F[idx] += X;\n        idx += idx & -idx;  // Move to parent node\n    }\n}\n// Calculate prefix sum from 1 to idx\nint sum(int idx) {\n    int res = 0;\n    while (idx > 0) {\n        res += F[idx];\n        idx -= idx & -idx;  // Move to previous node\n    }\n    return res;\n}\n// Calculate range sum from l to r (inclusive)\nint rangeQuery(int l, int r) {\n    return sum(r) - sum(l - 1);\n}\nint main() {\n    // Initialize array (1-based indexing)\n    vector<int> arr = {-1e9, 1, 2, 3, 4, 5};\n    int n = 5;  // Actual number of elements\n    // Build Fenwick tree\n    for (int i = 1; i <= n; i++) {\n        add(i, arr[i]);\n    }\n    // Test queries\n    cout << \"Sum [1..3]: \" << rangeQuery(1, 3) << \"\\n\";  // 6\n    cout << \"Sum [2..5]: \" << rangeQuery(2, 5) << \"\\n\";  // 14\n    // Update element at position 3 to 7\n    add(3, 7 - arr[3]);\n    arr[3] = 7;\n    // Test queries after update\n    cout << \"Sum [1..3]: \" << rangeQuery(1, 3) << \"\\n\";  // 10\n    cout << \"Sum [2..5]: \" << rangeQuery(2, 5) << \"\\n\";  // 18\n    return 0;\n}",
    "visualization": "done"
  }