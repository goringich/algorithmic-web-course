{
    "title": "Дерево Фенвика в многомерном пространстве",
    "content": ["       Дерево Фенвика или двоичное индексированное дерево – это структура данных, используемая для вычисления запросов по диапазону или интервалу в массиве за логарифмическое время. Дерево Фенвика может быть обобщено для нескольких измерений, поэтому его знание является необходимым условием для рассмотрения многомерного случая.",
    "__Определение__\n        Рассмотрим для двумерного случая, рассуждения для больших размерностей аналогичны. Пусть дан массив a из n*m элементов. Деревом Фенвика будем называть массив T из n*m элементов:\n $$T_{i,j} = \\sum_{k=F(i)}^{i} \\sum_{q=F(j)}^{j} a_{k,q}$,\n где F(i) = i & (i + 1), как и в одномерном случае.",
"__Основная идея__\n        Наиболее распространенной реализацией алгоритма является сумма всех элементов подматрицы. Поэтому рассмотрим решение простейшей задачи этим методом.\n\n        Рассмотрим двумерную матрицу, в которой мы хотим найти сумму подматрицы, ограниченной координатами (x1, x2) и (y1, y2). Без сложных математических вычислений мы понимаем, что она выглядит, как:\n\nsum((x1, y1), (x2, y2)) = sum((0, 0), (x2, y2)) - sum((0, 0), (x1-1, y2)) - sum((0, 0), (x2, y1-1)) + sum((0, 0), (x1-1, y1-1))\n\n        Уже по этой формуле видно, что она следует из принципа включения-исключения комбинаторики и именно этот принцип помогает нам обобщить этот алгоритм на большие размерности.",
"__Запрос суммы__\n        ^^Используем формулу включения-исключения.^^\n__Запрос обновления__\n        При изменение ячейки aᵢⱼ мы обновляем все ячейки, в которых она задействована."],
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nconst int MAX_N = 100;  // Maximum matrix dimension\nvector<vector<int>> F(MAX_N, vector<int>(MAX_N, 0));  // 2D Fenwick Tree (1-based indexing)\nvoid update(int x, int y, int X) {//Updates the value at position (x,y) by adding X\n    for (int i = x; i < MAX_N; i += i & -i) {  // Move to parent rows\n        for (int j = y; j < MAX_N; j += j & -j) {  // Move to parent columns\n            F[i][j] += X;\n        }\n    }\n}\nint prefixSum(int x, int y) {//Calculates prefix sum from (1,1) to (x,y)\n    int res = 0;\n    for (int i = x; i > 0; i -= i & -i) {  // Move to previous rows\n        for (int j = y; j > 0; j -= j & -j) {  // Move to previous columns\n            res += F[i][j];\n        }\n    }\n    return res;\n}\nint rangeSum(int x1, int y1, int x2, int y2) {//Calculates sum of elements in rectangle from (x1,y1) to (x2,y2)\n    return prefixSum(x2, y2) - prefixSum(x1-1, y2) - prefixSum(x2, y1-1) + prefixSum(x1-1, y1-1);\n}\nint main() {\n    // Initialize array \n    vector<vector<int>> matrix = {\n        {0, 0, 0, 0, 0},\n        {0, 1, 2, 3, 4},\n        {0, 5, 6, 7, 8},\n        {0, 9, 10, 11, 12},\n        {0, 13, 14, 15, 16}\n    };\n    int n = 4;\n    // Build Fenwick tree\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            update(i, j, matrix[i][j]);\n        }\n    }\n    // Test queries\n    cout << 'Sum [(1,1)..(2,2)]: ' << rangeSum(1, 1, 2, 2) << '\\n';  // 1+2+5+6 = 14\n    cout << 'Sum [(2,2)..(4,4)]: ' << rangeSum(2, 2, 4, 4) << '\\n';  // 6+7+8+10+11+12+14+15+16 = 99\n    // update element (3,3)  20\n    update(3, 3, 20 - matrix[3][3]);\n    matrix[3][3] = 20;\n    // Test quaries after updating\n    cout << 'Sum [(1,1)..(3,3)]: ' << rangeSum(1, 1, 3, 3) << '\\n';  // 1+2+3+5+6+7+9+10+20 = 63 \n    cout << 'Sum [(2,2)..(4,4)]: ' << rangeSum(2, 2, 4, 4) << '\\n';  // 6+7+8+10+20+12+14+15+16 = 109 \n    return 0;\n}",
    "visualization": ""
  }