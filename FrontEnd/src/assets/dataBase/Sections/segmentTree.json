{
  "title": "Дерево отрезков с суммами",
  "content": "Дерево отрезков с суммами — это структура данных, предназначенная для эффективных вычислений сумм на подотрезках массива. Она позволяет быстро (за логарифмическое время) вычислять сумму элементов на отрезке и обновлять элементы массива.\n\nДерево отрезков - структура данных, позволяющая выполнять многие операции с отрезками массива за O(logN). Дерево отрезков - универсальная структура данных, для которой можно реализовать неограниченный набор операций (иногда за большую сложность: O(log2N)).\n\nДля чего нужен этот алгоритм?\nК примеру, представьте, что надо найти сумму последовательности чисел, при этом нам нужно не просто вычислить сумму чисел указанной последовательности (сумму элементов определённого массива), а максимально быстро найти сумму любой последовательности из этих чисел. То есть мы можем задать какой-нибудь интервал (отрезок) и максимально быстро дать ответ, чему равна сумма чисел из этого интервала.\n\nЧто значит быстро? Это значит быстрее, чем, если бы мы просто суммировали числа. Ведь чисел может быть и миллионы, и миллиарды…\n\nИменно желание быстро находить сумму последовательных элементов и стало мотивацией для создания данного алгоритма. Причём, речь идёт не только о сумме, но и о других задачах, например, вычислении любой ассоциативной функции. Таким образом, мы говорим об операциях, выполнение которых не зависит от порядка вычисления.\n\nПостроение дерева отрезков\nДерево отрезков - полное бинарное дерево, в котором каждая вершина отвечает за некоторый отрезок в массиве. Корень дерева отвечает за весь массив, его две дочерних вершины - за две половины, и так далее. У каждой вершины, отвечающей за отрезок длиной больше 1, есть две дочерних вершины, отвечающих за левую и правую половины этого отрезка. Листья дерева отрезков отвечают за отдельные элементы (отрезки длиной 1).\n\nДля массива из n элементов дерево отрезков имеет около 2n вершин (n+n/2+n/4+…), а его высота равна порядка logn.\n\nГлавное свойство дерева отрезков, на котором и строятся все алгоритмы работы с ним: любой непрерывный отрезок в массиве из n элементов можно представить с помощью около 2logn вершин в дереве отрезков.\n\nНесколько важных замечаний:\n• Нумеровать этот массив удобно с единицы. Таким образом легко вычислять номер детей и родителей. Формула вычисления «левого ребёнка»: i*2, «правого»: i*2+1.\n• Чтобы от \"ребенка\" подняться к \"родителю\", используем целочисленное деление i / 2.\n• У левых детей чётные номера, у правых — нечётные.\n\nОписание алгоритма\nМы знаем, что во всех вершинах лежат корректные значения. Тогда мы можем создать рекурсивную функцию, рассмотрев три случая:\n• Если отрезок вершины лежит целиком в отрезке запроса, то вернуть записанную в ней сумму.\n• Если отрезки вершины и запроса не пересекаются, то вернуть 0.\n• Иначе разделиться рекурсивно на 2 и вернуть сумму этой функции от обоих детей.\n\nЧтобы разобраться, почему это работает за O(logn), нужно оценить количество «интересных» отрезков — тех, которые порождают новые вызовы рекурсии. Это будут только те, которые содержат границу запросов — остальные сразу завершатся. Обе границы отрезка содержатся в O(logn) отрезках, а значит и итоговая асимптотика будет такая же.",
  "code": "class SegmentTree {...}",
  "visualization": "Здесь будет визуализация дерева отрезков."
}
