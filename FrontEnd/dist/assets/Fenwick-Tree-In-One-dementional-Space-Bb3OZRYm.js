const n="Дерево Фенвика в одномерном пространстве",e=["        Дерево Фенвика или двоичное индексированное дерево — это структура данных, используемая для вычисления запросов по диапазону, а также для обновления элементов массива таким образом, чтобы каждый запрос или обновление занимали логарифмическое время, а сама структура занимала в памяти O(n). Оно используется для вычисления префиксных сумм или текущего итога значений для любого индекса, заменяя при этом дерево отрезков и работая в 3-4 раза быстрее.",`__Определение__
        Пусть дан массив a длины n. Деревом Фенвика будем называть массив t той же длины, объявленный следующим образом:
$$T_i = \\sum_{k=F(i)^{i}} a_k$
где F это какая-то функцию, для которой выполнено F(i) <= i.

        Функцию F можно выбрать так, чтобы спусков по дереву при подсчете суммы и ячеек, требующих изменений при обновлении, будет О(log n). Популярны две функции:
F₁(x) = x & (x + 1)
F₂(x) = x - (x & -x) + 1

        Первая функция более известная, однако вторая легче для запоминания и кодинга в целом.`,`__Основная идея__
        Рассмотрим дерево Фенвика как массив F[ ] с индексацией, начинающейся с 1, в котором каждый индекс массива хранит частичную сумму диапазона. Для простоты предположим, что размер массива F[ ] равен 16. Таким образом, для любого индекса i, F[i] будет хранить сумму значений от индекса j+1 до i, где j = i - (самый правый установленный бит в i). Чтобы понять диапазон значений, обратитесь к [[TABLE_LINK]]:`,{type:"table",headers:["Значение i","Двоичное представление","Самый правый установленный бит i","Значение j","Диапазон частичной суммы [начало, конец]"],rows:[["0","0000","0000","0000"," — "],["1","0001","0001","0000","[1, 1]"],["2","0010","0010","0000","[1, 2]"],["3","0011","0001","0010","[3, 3]"],["4","0100","0100","0000","[1, 4]"],["5","0101","0001","0100","[5, 5]"],["6","0110","0010","0100","[5, 6]"],["7","0111","0001","0110","[7, 7]"],["8","1000","1000","0000","[1, 8]"],["9","1001","0001","1000","[9, 9]"],["10","1010","0010","1000","[9, 10]"],["11","1011","0001","1010","[11, 11]"],["12","1100","0100","1000","[9, 12]"],["13","1101","0001","1100","[13, 13]"],["14","1110","0010","1100","[13, 14]"],["15","1111","0001","1110","[15, 15]"]]},`        Итак, из приведённой выше таблицы мы видим, что каждый индекс дерева Фенвика F[ ] хранит сумму диапазона. Теперь, если нам нужно вычислить префиксную сумму до 7-го элемента, то вместо того, чтобы перебирать числа от 1 до 7 и вычислять сумму, мы можем взять сумму F[7] + F[6] + F[4].

        Префиксная сумма до 7-го элемента = F[7] + F[6] + F[4], 7 --удалить самый правый установленный бит --> 6 --удалить самый правый установленный бит --> 4 --удалить самый правый установленный бит --> 0.

        Теперь, чтобы вычислить сумму диапазона [L, R], мы можем просто вычесть сумму префиксов до [L-1] из суммы префиксов до R.`,`__Запрос суммы__
        ^^Когда нам нужна сумма на отрезке, мы будем сводить этот запрос к двум суммам на префиксе: sum(l,r) = sum(r) − sum(l−1). Оба этих запроса будем считать по формуле: sum(k) =tₖ + sum(F(k)−1)^^

__Запрос обновления__
        Когда мы изменяем k-ю ячейку исходного массива, мы обновляем все tᵢ, в которых учтена эта ячейка.`,`__Почему это работает?__
        ^^Итак, мы выбрали вариант с F(x) = x-(x & -x)+1. Поймем, что означает x &-x.^^

__Лемма__  ^^x & -x возвращает последний единичный бит в двоичной записи x.^^
__Следствие 1__  ^^sum будет работать за логарифм, а точнее за количество единичных битов в записи x: на каждой итерации мы делаем x -= x & -x, то есть удаляем младший бит.^^
__Следствие 2.__  ^^add тоже будет работать за логарифм: каждую итерацию количество нулей на конце x увеличивается хотя бы на единицу.^^
__Следствие 3__  ^^(Почему дерево Фенвика — дерево.)^^

1)  Длина отрезка, соответствующего любому tᵢ — степень двойки, причём начинается этот отрезок на индексе, кратном этой же степени двойки.
2)  Множества элементов, учтённых в произвольных tᵢ и tⱼ, либо не пересекаются, либо одно является подмножеством другого.
3)  На tᵢ можно ввести отношение вложенности.

        То есть, если напрячь воображение, то t можно рассматривать как лес деревьев. В частном случае, когда n является степенью двойки, дерево будет одно. Теперь единственное, что осталось доказать — это корректность add. На самом деле, в add мы делаем ни что иное, как подъём от вершины до корня по всем предкам.
        Как для x найти непосредственного родителя? Нужно найти минимальное число y>x, у которого ty будет включать x. Иными словами, должно выполняться y >= x > y - (y & -y).`],i=`#include <bits/stdc++.h>
using namespace std;
const int MAX_N = 100010;  // Maximum possible array size
vector<int> F(MAX_N, 0);  // Fenwick tree (1-based indexing)
// Add value X to element at position idx
void add(int idx, int X) {
    while (idx < MAX_N) {
        F[idx] += X;
        idx += idx & -idx;  // Move to parent node
    }
}
// Calculate prefix sum from 1 to idx
int sum(int idx) {
    int res = 0;
    while (idx > 0) {
        res += F[idx];
        idx -= idx & -idx;  // Move to previous node
    }
    return res;
}
// Calculate range sum from l to r (inclusive)
int rangeQuery(int l, int r) {
    return sum(r) - sum(l - 1);
}
int main() {
    // Initialize array (1-based indexing)
    vector<int> arr = {-1e9, 1, 2, 3, 4, 5};
    int n = 5;  // Actual number of elements
    // Build Fenwick tree
    for (int i = 1; i <= n; i++) {
        add(i, arr[i]);
    }
    // Test queries
    cout << "Sum [1..3]: " << rangeQuery(1, 3) << "\\n";  // 6
    cout << "Sum [2..5]: " << rangeQuery(2, 5) << "\\n";  // 14
    // Update element at position 3 to 7
    add(3, 7 - arr[3]);
    arr[3] = 7;
    // Test queries after update
    cout << "Sum [1..3]: " << rangeQuery(1, 3) << "\\n";  // 10
    cout << "Sum [2..5]: " << rangeQuery(2, 5) << "\\n";  // 18
    return 0;
}`,t="done",r={title:n,content:e,code:i,visualization:t};export{i as code,e as content,r as default,n as title,t as visualization};
//# sourceMappingURL=Fenwick-Tree-In-One-dementional-Space-Bb3OZRYm.js.map
